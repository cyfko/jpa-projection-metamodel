package io.github.cyfko.jpametamodel;

import io.github.cyfko.jpametamodel.api.PersistenceMetadata;
import io.github.cyfko.jpametamodel.providers.PersistenceRegistryProvider;

import java.util.*;
import java.util.stream.Stream;

/**
 * Provides centralized access to the JPA entity metadata registry generated at compile time.
 * <p>
 * This class acts as a facade for retrieving metadata about entity fields, including identifiers,
 * relationships, collections, and mapped IDs. It lazily loads the generated registry implementation
 * and caches it for subsequent access.
 * </p>
 *
 * <p>
 * The registry is expected to be generated by the {@code EntityRegistryProcessor} annotation processor
 * which SHOULD generates the implementation class
 * {@code io.github.cyfko.jpametamodel.providers.impl.PersistenceRegistryProviderImpl}.
 * </p>
 *
 * <p>
 * Typical usage:
 * <pre>{@code
 * // Get metadata for a specific entity
 * Map<String, PersistenceMetadata> metadata = PersistenceRegistry.getMetadataFor(User.class);
 *
 * // Check if entity is registered
 * boolean isRegistered = PersistenceRegistry.isEntityRegistered(User.class);
 *
 * // Get the full registry
 * EntityMetadataRegistryProvider registry = PersistenceRegistry.getEntityRegistry();
 * }</pre>
 * </p>
 *
 * <p>
 * If the registry cannot be loaded (e.g., due to missing generation or classpath issues),
 * an {@link IllegalStateException} is thrown with a detailed diagnostic message.
 * </p>
 *
 * <p><strong>Thread safety:</strong> The registry is loaded in a thread-safe manner using double-checked locking.</p>
 *
 * @author Frank Cyrille KOSSI
 * @see PersistenceRegistryProvider
 * @see PersistenceMetadata
 */
public final class PersistenceRegistry {

    private static volatile PersistenceRegistryProvider PROVIDER;
    private static final Map<Class<?>, List<String>> ENTITY_ID_FIELDS = new HashMap<>();

    // Private constructor to prevent instantiation
    private PersistenceRegistry() {
        throw new UnsupportedOperationException("PersistenceRegistry is a utility class and cannot be instantiated");
    }

    /**
     * Returns the full entity metadata registry provider.
     * <p>
     * This method uses double-checked locking to ensure thread-safe lazy initialization.
     * </p>
     *
     * @return the entity metadata registry provider
     * @throws IllegalStateException if the registry cannot be loaded
     */
    public static PersistenceRegistryProvider getProvider() {
        // 1. Si on a déjà chargé le provider, on le retourne directement (Cache)
        if (PROVIDER != null) {
            return PROVIDER;
        }

        // 2. TENTATIVE A : ServiceLoader (Méthode standard Java)
        // Cela fonctionne si le module-info est configuré ou si META-INF est présent
        ServiceLoader<PersistenceRegistryProvider> loader = ServiceLoader.load(PersistenceRegistryProvider.class);
        Iterator<PersistenceRegistryProvider> iterator = loader.iterator();

        if (iterator.hasNext()) {
            PROVIDER = iterator.next();
            return PROVIDER;
        }

        // 3. TENTATIVE B : Fallback Manuel (Réflexion)
        // Si le ServiceLoader échoue (souvent le cas en tests ou sans modules),
        // on force le chargement de la classe par son nom exact.
        try {
            String generatedClassName = "io.github.cyfko.jpametamodel.providers.impl.PersistenceRegistryProviderImpl";

            Class<?> clazz = Class.forName(generatedClassName);
            PROVIDER = (PersistenceRegistryProvider) clazz.getDeclaredConstructor().newInstance();

            return PROVIDER;
        } catch (Exception e) {
            throw new IllegalStateException(
                    "Cannot load metadata registry: PersistenceRegistryProviderImpl class not found. " +
                    "Ensure that the annotation processor has run and generated the registry class. " +
                    "Check that 'io.github.cyfko:jpa-metamodel-processor' is configured as an annotation processor.",
                    e
            );
        }
    }

    /**
     * Returns metadata for all fields of the specified entity/embeddable class.
     *
     * @param entityClass the entity class to retrieve metadata for
     * @return a map of field names to their metadata, or {@code null} if the entity is not registered
     * @throws NullPointerException if entityClass is null
     */
    public static Map<String, PersistenceMetadata> getMetadataFor(Class<?> entityClass) {
        return isEntityRegistered(entityClass) ? getProvider().getEntityMetadataRegistry().get(entityClass) : getProvider().getEmbeddableMetadataRegistry().get(entityClass);
    }

    /**
     * Resolves the Java type of a field path within an entity.
     * <p>
     * Supports dotted paths through embeddables, related entities, and collections.
     * For collection segments, navigation continues into the element type.
     * </p>
     *
     * Examples:
     * <pre>{@code
     *   getFieldType(User.class, "id")                        // → Long.class
     *   getFieldType(User.class, "address.city")              // → String.class  (address is @Embeddable)
     *   getFieldType(User.class, "department.employees.salary") // → BigDecimal.class
     * }</pre>
     *
     * @param rootEntity the root entity class
     * @param fieldPath  dot-separated field path (e.g. "address.city")
     * @return the resolved {@link Class} of the terminal field
     * @throws IllegalArgumentException if any segment of the path cannot be resolved
     */
    public static Class<?> getFieldType(Class<?> rootEntity, String fieldPath) {
        Objects.requireNonNull(rootEntity,  "rootEntity cannot be null");
        Objects.requireNonNull(fieldPath,   "fieldPath cannot be null");

        String[] segments = fieldPath.split("\\.");
        Class<?> currentType = rootEntity;

        for (String segment : segments) {
            // Récupère les métadonnées du type courant (entité ou embeddable)
            Map<String, PersistenceMetadata> metadata = getMetadataFor(currentType);

            if (metadata == null) {
                throw new IllegalArgumentException(
                        "Type '%s' is not a registered entity or embeddable (reached while resolving '%s' in path '%s')"
                                .formatted(currentType.getSimpleName(), segment, fieldPath)
                );
            }

            PersistenceMetadata fieldMeta = metadata.get(segment);

            if (fieldMeta == null) {
                throw new IllegalArgumentException(
                        "Field '%s' not found in '%s' (full path: '%s')"
                                .formatted(segment, currentType.getSimpleName(), fieldPath)
                );
            }

            // relatedType = type de l'élément (pour les collections, c'est le type de l'élément)
            currentType = fieldMeta.relatedType();
        }

        return currentType;
    }

    /**
     * Checks if the specified entity class is registered in the metadata registry.
     *
     * @param entityClass the entity class to check
     * @return {@code true} if the entity is registered, {@code false} otherwise
     * @throws NullPointerException if entityClass is null
     */
    public static boolean isEntityRegistered(Class<?> entityClass) {
        if (entityClass == null) {
            throw new NullPointerException("Entity class cannot be null");
        }
        return getProvider().getEntityMetadataRegistry().containsKey(entityClass);
    }

    /**
     * Checks if the specified embeddable class is registered in the metadata registry.
     *
     * @param embeddableClass the embeddable class to check
     * @return {@code true} if the embeddable is registered, {@code false} otherwise
     * @throws NullPointerException if entityClass is null
     */
    public static boolean isEmbeddableRegistered(Class<?> embeddableClass) {
        if (embeddableClass == null) {
            throw new NullPointerException("Entity class cannot be null");
        }
        return getProvider().getEmbeddableMetadataRegistry().containsKey(embeddableClass);
    }

    /**
     * Returns the total number of registered entities.
     *
     * @return the number of registered entities
     */
    public static int getRegisteredEntityCount() {
        return getProvider().getEntityMetadataRegistry().size();
    }

    /**
     * Returns metadata for a specific field of the specified entity class or embeddable class.
     *
     * @param entityClass the entity class
     * @param fieldName the name of the field
     * @return the field metadata, or {@code null} if the entity or field is not found
     * @throws NullPointerException if entityClass or fieldName is null
     */
    public static PersistenceMetadata getFieldMetadata(Class<?> entityClass, String fieldName) {
        if (entityClass == null) {
            throw new NullPointerException("Entity class cannot be null");
        }
        if (fieldName == null) {
            throw new NullPointerException("Field name cannot be null");
        }

        Map<String, PersistenceMetadata> entityMetadata = getMetadataFor(entityClass);
        return entityMetadata != null ? entityMetadata.get(fieldName) : null;
    }

    /**
     * Finds the ID fields (maybe a primary key or a composite primary key) for an entity using PersistenceRegistry.
     */
    public static synchronized List<String> getIdFields(Class<?> entityClass) {
        if (ENTITY_ID_FIELDS.containsKey(entityClass)) return ENTITY_ID_FIELDS.get(entityClass);

        Map<String, PersistenceMetadata> metadata = PersistenceRegistry.getMetadataFor(entityClass);
        if (metadata == null) {
            throw new IllegalStateException("No metadata found for entity: " + entityClass.getName());
        }

        List<String> idFields = metadata.entrySet().stream()
                .filter(e -> e.getValue().isId())
                .flatMap(PersistenceRegistry::extractIdFields)
                .toList();

        if (idFields.isEmpty()) {
            throw new IllegalStateException("No @Id field found in entity: " + entityClass.getSimpleName());
        }

        ENTITY_ID_FIELDS.put(entityClass, idFields);
        return idFields;
    }

    private static Stream<String> extractIdFields(Map.Entry<String,PersistenceMetadata> entry) {
        // If embeddable then unwrap all its fields
        Class<?> clazz = entry.getValue().relatedType();
        if (PersistenceRegistry.isEmbeddableRegistered(clazz)) {
            return PersistenceRegistry.getMetadataFor(clazz).keySet().stream();
        } else {
            return Stream.of(entry.getKey());
        }
    }

    /**
     * Clears the cached registry. Useful for testing purposes.
     * <p>
     * <strong>Warning:</strong> This method is intended for testing only and should not be used in production code.
     * </p>
     */
    static void clearCache() {
        synchronized (PersistenceRegistry.class) {
            PROVIDER = null;
        }
    }
}